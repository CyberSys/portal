(desc:(eng:"",rus:""),cam:(look_at:(0,0,0),alpha:4.455762527278276,beta:1.413836868628872,r:2.1732246307070646,offset_after_material:0.000025),uniforms:(ids:(available:[],max:0),storage:{},storage_order:[]),matrices:(ids:(available:[(0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12)],max:14),storage:{(13):Inline(Simple(offset:(0,0,0),scale:1,rotate:(0,0,0),mirror:(false,false,false)))},storage_order:[]),objects:(ids:(available:[(0),(1),(2),(3),(4),(5)],max:7),storage:{(6):Named(Flat(kind:Simple(Some(((13)))),is_inside:(("if (x*x + y*y < 5.) {\n  return digits_M;\n} else {\n  return NOT_INSIDE;\n}")),in_subspace:Normal),"digits_surface")},storage_order:[(6)]),cameras:(ids:(available:[],max:0),storage:{},storage_order:[]),textures:(ids:(available:[],max:0),storage:{},storage_order:[]),materials:(ids:(available:[(0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20)],max:22),storage:{(21):Named(Complex(code:(("return material_simple(hit, r, vec3(9.21e-2, 7.28e-1, 6.81e-2) * digits1(hit), 5e-1, true, 4e0, 3e-1);"))),"digits")},storage_order:[(21)]),intersection_materials:(ids:(available:[],max:0),storage:{},storage_order:[]),library:(ids:(available:[(0),(1),(2),(3)],max:5),storage:{(4):Named((("float DigitBin(const in int x) {\r\n  return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\r\n}\r\n\r\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value, float digits, float decimals) {\r\n  vec2 charCoord = (fragCoord - pixelCoord) / fontSize;\r\n  if(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\r\n  float bits = 0.0;\r\n  float digitIndex1 = digits - floor(charCoord.x)+ 1.0;\r\n  if(- digitIndex1 <= decimals) {\r\n    float pow1 = pow(10.0, digitIndex1);\r\n    float absValue = abs(value);\r\n    float pivot = max(absValue, 1.5) * 10.0;\r\n    if(pivot < pow1) {\r\n      if(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\r\n    } else if(digitIndex1 == 0.0) {\r\n      if(decimals > 0.0) bits = 2.0;\r\n    } else {\r\n      value = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\r\n      bits = DigitBin(int (mod(value / pow1, 10.0)));\r\n    }\r\n  }\r\n  return floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\r\n}\r\n\r\nfloat number(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value) {\r\n  return 1. - PrintValue(fragCoord, pixelCoord, fontSize, value, 0., 0.);\r\n}\r\n\r\nfloat draw_digits_spiral(vec2 uv, vec2 fontSize, int count) {\r\n  float result = 1.;\r\n  int x = 0;\r\n  int y = 0;\r\n  int lap = 1; // Tracks the current lap. The value also indirectly tracks the maximum number of steps in current lap direction.\r\n  int steps = 0; // Tracks number of steps taken in the current lap direction.\r\n  int direction = 0; // 0: Right, 1: Up, 2: Left, 3: Down\r\n  int stepLimit = 1; // Tracks steps limit in the current direction.\r\n\r\n  // Define your loop maximum, adjust based on your needs.\r\n  for (int i = 0; i < 300; ++i) {\r\n    if (i >= count) break;\r\n    // Use the coordinates: (x, y)\r\n    result *= number(uv, vec2(float(x), float(y)), fontSize, float(i));\r\n\r\n    // Move to the next cell in the current direction.\r\n    if (direction == 0) x += 1;\r\n    else if (direction == 1) y -= 1;\r\n    else if (direction == 2) x -= 1;\r\n    else if (direction == 3) y += 1;\r\n\r\n    steps++;\r\n\r\n    // Change direction logic.\r\n    if (steps == stepLimit) {\r\n      direction = direction + 1; // Change direction.\r\n      if (direction >= 4) direction = 0;\r\n      steps = 0; // Reset step counter for the new direction.\r\n      // After completing a lap in the horizontal directions (right/left), increment step limit.\r\n      if (direction == 0 || direction == 2) {\r\n        lap++; // Completed a lap, increase its range.\r\n        stepLimit = lap;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfloat digits1(SurfaceIntersection hit) {\r\n  // return 1.;\r\n  return draw_digits_spiral(vec2(-hit.u, hit.v)*4., vec2(4,5) * vec2(5,3)/200., 300);\r\n}\r\n")),"digits")},storage_order:[(4)]),animations_filters:(uniforms:({}),matrices:({}),cameras:({})),elements_descriptions:(uniforms:({}),matrices:({}),cameras:({})),user_uniforms:(uniforms:({}),matrices:({})),animation_stages:(ids:(available:[],max:0),storage:{},storage_order:[]),current_stage:None,dev_stage:(uniforms:({((0)):Float((min:Some(0),max:None,value:4)),((7)):Bool(true),((1)):Float((min:Some(0),max:None,value:4)),((8)):Bool(false),((6)):Progress(0),((2)):Float((min:Some(0),max:None,value:4))}),matrices:({((0)):Simple(offset:(0,0,0),scale:1,rotate:(0,0,0),mirror:(false,false,false))})),use_time:false)